#!/usr/bin/env python3
"""
Homelab CLI - Tooling for managing Docker services on the NAS.

Usage:
    homelab <command> [options]

Commands:
    env sync     Sync .env with .env.example
    lint         Check compose.yml order and naming conventions
"""

import argparse
import re
import sys
from dataclasses import dataclass, field
from pathlib import Path

__version__ = "0.6.0"

COMPOSE_PROPERTY_ORDER = [
    "container_name", "depends_on", "env_file", "environment", "healthcheck",
    "image", "labels", "logging", "networks", "ports", "restart", "user", "volumes",
]

NAS_DIR = Path("/mnt/home/thomas/workspace/homelab/nas")
CONFIG_FILE = NAS_DIR / ".homelabignore"


@dataclass
class LintConfig:
    exclude_routers: set[str] = field(default_factory=set)
    exclude_middlewares: set[str] = field(default_factory=set)
    exclude_logging: set[str] = field(default_factory=set)
    exclude_network: set[str] = field(default_factory=set)


def load_config() -> LintConfig:
    """Load configuration from .homelab.yml."""
    config = LintConfig()
    if not CONFIG_FILE.exists():
        return config

    content = CONFIG_FILE.read_text()
    current_section = None

    for line in content.splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue

        # Check for section headers
        if stripped == "exclude:":
            continue
        if stripped.endswith(":") and not stripped.startswith("-"):
            section = stripped.rstrip(":")
            if section == "routers":
                current_section = "routers"
            elif section == "middlewares":
                current_section = "middlewares"
            elif section == "logging":
                current_section = "logging"
            elif section == "network":
                current_section = "network"
            else:
                current_section = None
            continue

        # Parse list items
        if stripped.startswith("- ") and current_section:
            value = stripped[2:].strip()
            if current_section == "routers":
                config.exclude_routers.add(value)
            elif current_section == "middlewares":
                config.exclude_middlewares.add(value)
            elif current_section == "logging":
                config.exclude_logging.add(value)
            elif current_section == "network":
                config.exclude_network.add(value)

    return config


class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    GRAY = "\033[90m"
    CYAN = "\033[96m"
    RESET = "\033[0m"
    BOLD = "\033[1m"

    @classmethod
    def disable(cls):
        for attr in ["RED", "GREEN", "YELLOW", "BLUE", "GRAY", "CYAN", "RESET", "BOLD"]:
            setattr(cls, attr, "")


class Table:
    def __init__(self, headers: list[str]):
        self.headers = headers
        self.rows: list[list[str]] = []
        self.widths = [len(h) for h in headers]

    def add_row(self, row: list[str]) -> None:
        self.rows.append(row)
        for i, cell in enumerate(row):
            clean = re.sub(r"\033\[[0-9;]*m", "", cell)
            self.widths[i] = max(self.widths[i], len(clean))

    def render(self) -> str:
        if not self.rows:
            return ""
        def pad(text: str, width: int) -> str:
            clean = re.sub(r"\033\[[0-9;]*m", "", text)
            return text + " " * (width - len(clean))
        lines = []
        header_line = "  ".join(pad(h, self.widths[i]) for i, h in enumerate(self.headers))
        lines.append(f"{Colors.BOLD}{header_line}{Colors.RESET}")
        lines.append(f"{Colors.GRAY}{chr(9472) * (sum(self.widths) + 2 * (len(self.headers) - 1))}{Colors.RESET}")
        for row in self.rows:
            lines.append("  ".join(pad(cell, self.widths[i]) for i, cell in enumerate(row)))
        return "\n".join(lines)


@dataclass
class LintIssue:
    category: str
    message: str
    fix: str = ""


@dataclass
class ServiceLint:
    name: str
    path: Path
    order_issues: list[LintIssue] = field(default_factory=list)
    router_issues: list[str] = field(default_factory=list)
    middleware_issues: list[str] = field(default_factory=list)
    config_issues: list[str] = field(default_factory=list)

    @property
    def has_errors(self) -> bool:
        return bool(self.order_issues or self.router_issues or self.middleware_issues or self.config_issues)

    @property
    def error_count(self) -> int:
        return len(self.order_issues) + len(self.router_issues) + len(self.middleware_issues) + len(self.config_issues)


@dataclass
class EnvSyncResult:
    service: str
    action: str
    target: str
    variables: list[str] = field(default_factory=list)


def get_services() -> list[Path]:
    services = []
    for item in NAS_DIR.iterdir():
        if item.is_dir() and (item / "compose.yml").exists():
            services.append(item)
    return sorted(services)


def parse_env_file(path: Path) -> dict[str, str]:
    """Parse .env file into dict, preserving order."""
    env = {}
    if not path.exists():
        return env
    with open(path, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            match = re.match(r"^([A-Z_][A-Z0-9_]*)=(.*)$", line, re.IGNORECASE)
            if match:
                env[match.group(1)] = match.group(2)
    return env


def read_env_lines(path: Path) -> list[str]:
    """Read .env file as list of lines."""
    if not path.exists():
        return []
    return path.read_text().splitlines()


def find_insert_position(lines: list[str], new_key: str, reference_keys: list[str]) -> int:
    """Find best position to insert a new key based on prefix matching."""
    # Find common prefix with new_key
    prefix = ""
    for i in range(len(new_key)):
        if new_key[i] == "_":
            prefix = new_key[:i+1]
    
    # Find last line with same prefix
    last_match_idx = -1
    for i, line in enumerate(lines):
        if line.startswith("#") or not line.strip():
            continue
        match = re.match(r"^([A-Z_][A-Z0-9_]*)=", line, re.IGNORECASE)
        if match:
            key = match.group(1)
            if prefix and key.startswith(prefix):
                last_match_idx = i
    
    if last_match_idx >= 0:
        return last_match_idx + 1
    return len(lines)


def add_vars_to_env_file(path: Path, vars_to_add: dict[str, str], source_keys_order: list[str]) -> None:
    """Add variables to env file at appropriate positions."""
    lines = read_env_lines(path)
    
    for key in source_keys_order:
        if key not in vars_to_add:
            continue
        value = vars_to_add[key]
        new_line = f"{key}={value}"
        
        # Find existing keys for reference
        existing_keys = []
        for line in lines:
            match = re.match(r"^([A-Z_][A-Z0-9_]*)=", line, re.IGNORECASE)
            if match:
                existing_keys.append(match.group(1))
        
        pos = find_insert_position(lines, key, existing_keys)
        lines.insert(pos, new_line)
    
    path.write_text("\n".join(lines) + "\n")


def confirm(prompt: str) -> bool:
    try:
        response = input(f"{prompt} [y/N] ").strip().lower()
        return response in ("y", "yes")
    except (EOFError, KeyboardInterrupt):
        print()
        return False


def cmd_env_sync(args) -> int:
    service_name = args.service
    force = getattr(args, "force", False)

    if service_name:
        services = [NAS_DIR / service_name]
        if not services[0].exists():
            print(f"{Colors.RED}Error: Service not found: {service_name}{Colors.RESET}")
            return 1
    else:
        services = get_services()

    table = Table(["Service", "Status", "Changes"])
    sync_results: list[EnvSyncResult] = []

    for service_dir in services:
        env_example = service_dir / ".env.example"
        env_file = service_dir / ".env"
        service = service_dir.name

        if not env_example.exists():
            continue

        example_vars = parse_env_file(env_example)
        env_vars = parse_env_file(env_file)

        # Case 1: .env does not exist - create from .env.example
        if not env_file.exists():
            env_file.write_text(env_example.read_text())
            table.add_row([service, f"{Colors.GREEN}+ created{Colors.RESET}", f"{len(example_vars)} vars"])
            sync_results.append(EnvSyncResult(service, "created", ".env", sorted(example_vars.keys())))
            continue

        # Find differences in BOTH directions
        only_in_env = set(env_vars.keys()) - set(example_vars.keys())
        only_in_example = set(example_vars.keys()) - set(env_vars.keys())

        if not only_in_env and not only_in_example:
            table.add_row([service, f"{Colors.GREEN}✓ synced{Colors.RESET}", f"{Colors.GRAY}-{Colors.RESET}"])
            continue

        changes = []
        
        # Always add missing vars from .env to .env.example (no confirmation needed)
        if only_in_env:
            vars_to_add = {k: "''" for k in only_in_env}  # Empty values for .env.example
            env_keys_order = list(env_vars.keys())
            add_vars_to_env_file(env_example, vars_to_add, env_keys_order)
            changes.append(f"+{len(only_in_env)} example")
            sync_results.append(EnvSyncResult(service, "to_example", ".env.example", sorted(only_in_env)))

        # Add missing vars from .env.example to .env (with confirmation)
        if only_in_example:
            if force:
                do_sync = True
            else:
                print(f"\n{Colors.BOLD}{service}{Colors.RESET}: .env.example has variables not in .env:")
                for key in sorted(only_in_example):
                    print(f"  {Colors.BLUE}+ {key}{Colors.RESET}")
                do_sync = confirm(f"Add {len(only_in_example)} variable(s) to .env?")

            if do_sync:
                vars_to_add = {k: example_vars[k] for k in only_in_example}
                example_keys_order = list(example_vars.keys())
                add_vars_to_env_file(env_file, vars_to_add, example_keys_order)
                changes.append(f"+{len(only_in_example)} env")
                sync_results.append(EnvSyncResult(service, "to_env", ".env", sorted(only_in_example)))
            else:
                changes.append(f"{len(only_in_example)} skipped")
                sync_results.append(EnvSyncResult(service, "skipped", ".env", sorted(only_in_example)))

        # Determine status
        if changes:
            status = f"{Colors.YELLOW}~ updated{Colors.RESET}"
            changes_str = ", ".join(changes)
        else:
            status = f"{Colors.GREEN}✓ synced{Colors.RESET}"
            changes_str = f"{Colors.GRAY}-{Colors.RESET}"
        
        table.add_row([service, status, changes_str])

    print()
    print(table.render())

    # Detailed output
    if sync_results:
        to_example = [r for r in sync_results if r.action == "to_example"]
        to_env = [r for r in sync_results if r.action == "to_env"]
        skipped = [r for r in sync_results if r.action == "skipped"]
        created = [r for r in sync_results if r.action == "created"]

        if created:
            print(f"\n{Colors.BOLD}Created{Colors.RESET}")
            for r in created:
                print(f"  {Colors.CYAN}{r.service}/.env{Colors.RESET}")
                for var in r.variables[:8]:
                    print(f"    {Colors.GREEN}+{Colors.RESET} {var}")
                if len(r.variables) > 8:
                    print(f"    {Colors.GRAY}+{len(r.variables) - 8} more{Colors.RESET}")

        if to_example:
            print(f"\n{Colors.BOLD}Added to .env.example{Colors.RESET}")
            for r in to_example:
                print(f"  {Colors.CYAN}{r.service}/.env.example{Colors.RESET}")
                for var in r.variables:
                    print(f"    {Colors.YELLOW}+{Colors.RESET} {var}")

        if to_env:
            print(f"\n{Colors.BOLD}Added to .env{Colors.RESET}")
            for r in to_env:
                print(f"  {Colors.CYAN}{r.service}/.env{Colors.RESET}")
                for var in r.variables:
                    print(f"    {Colors.GREEN}+{Colors.RESET} {var}")

        if skipped:
            print(f"\n{Colors.BOLD}Skipped{Colors.RESET} {Colors.GRAY}(run with -f to force){Colors.RESET}")
            for r in skipped:
                print(f"  {Colors.CYAN}{r.service}/.env{Colors.RESET}")
                for var in r.variables:
                    print(f"    {Colors.GRAY}?{Colors.RESET} {var}")

    return 0


def extract_compose_service_props(content: str) -> dict[str, list[tuple[str, int]]]:
    services = {}
    lines = content.split("\n")
    current_service = None
    in_services_block = False
    service_indent = None
    prop_indent = None

    for i, line in enumerate(lines, 1):
        stripped = line.lstrip()
        indent = len(line) - len(stripped)

        if stripped.startswith("services:"):
            in_services_block = True
            continue
        if not in_services_block:
            continue
        if indent == 0 and stripped and not stripped.startswith("#"):
            in_services_block = False
            continue
        if not stripped or stripped.startswith("#"):
            continue
        if service_indent is None and indent > 0 and stripped.endswith(":") and not stripped.startswith("-"):
            service_indent = indent
        if indent == service_indent and stripped.endswith(":") and not stripped.startswith("-"):
            service_name = stripped.rstrip(":").strip()
            current_service = service_name
            services[current_service] = []
            prop_indent = None
            continue
        if current_service and indent > service_indent:
            if prop_indent is None:
                prop_indent = indent
            if indent == prop_indent and ":" in stripped and not stripped.startswith("-"):
                prop_name = stripped.split(":")[0].strip()
                services[current_service].append((prop_name, i))

    return services


def find_order_fixes(props: list[tuple[str, int]]) -> list[LintIssue]:
    issues = []
    prop_names = [p[0] for p in props]
    known_props = [(name, line) for name, line in props if name in COMPOSE_PROPERTY_ORDER]

    if not known_props:
        return issues

    expected_order = [p for p in COMPOSE_PROPERTY_ORDER if p in prop_names]
    actual_order = [p[0] for p in known_props]

    if actual_order == expected_order:
        return issues

    out_of_order = []
    for i, (prop, line) in enumerate(known_props):
        expected_idx = expected_order.index(prop)
        for j in range(i):
            other_prop = known_props[j][0]
            other_expected_idx = expected_order.index(other_prop)
            if other_expected_idx > expected_idx:
                out_of_order.append((prop, line, other_prop))
                break

    if out_of_order:
        moves = {}
        for prop, line, before in out_of_order:
            if prop not in moves:
                moves[prop] = {"line": line, "before": before}

        for prop, info in moves.items():
            line_num = info["line"]
            before_prop = info["before"]
            issues.append(LintIssue(
                category="order",
                message=f":{line_num}",
                fix=f"move `{prop}` before `{before_prop}`"
            ))

    return issues


def find_router_issues(content: str, exclude: set[str] | None = None) -> list[str]:
    """Check router naming conventions.

    Rules:
    - If service has public routes (owpac.com): require -private/-public suffixes
    - If service is private-only (owpac.net): suffix optional, but if present must be -private
    """
    exclude = exclude or set()
    has_public = "owpac.com" in content

    router_pattern = r"traefik\.http\.routers\.([a-z0-9-]+)\."
    routers = set(re.findall(router_pattern, content))
    bad_routers = []

    for router in sorted(routers):
        if router == "wildcard-certs" or router in exclude:
            continue

        has_suffix = router.endswith("-private") or router.endswith("-public")

        if has_public:
            # Public service: suffix required
            if not has_suffix:
                bad_routers.append(f"{router} (missing -private/-public)")
        else:
            # Private-only: suffix optional, but if present must be -private
            if router.endswith("-public"):
                bad_routers.append(f"{router} (use -private for owpac.net)")

    return bad_routers


def find_middleware_issues(content: str, exclude: set[str] | None = None) -> list[str]:
    """Check middleware configuration.

    Rules:
    - Public routes (owpac.com) must use wan@file middleware
    - Private routes (owpac.net) must use lan@file middleware
    """
    exclude = exclude or set()
    issues = []

    # Find all router rules with their middlewares
    # Pattern: traefik.http.routers.<name>.rule and traefik.http.routers.<name>.middlewares
    router_pattern = r"traefik\.http\.routers\.([a-z0-9-]+)\.rule[^:]*:[^`]*`([^`]+)`"
    middleware_pattern = r"traefik\.http\.routers\.([a-z0-9-]+)\.middlewares[^:]*:[^\n]*"

    rules = dict(re.findall(router_pattern, content))

    for match in re.finditer(middleware_pattern, content):
        router = match.group(1)
        middleware_line = match.group(0)

        if router == "wildcard-certs" or router in exclude:
            continue

        rule = rules.get(router, "")
        is_public = "owpac.com" in rule
        is_private = "owpac.net" in rule

        has_wan = "wan@file" in middleware_line
        has_lan = "lan@file" in middleware_line

        if is_public and not has_wan:
            issues.append(f"{router} (public needs wan@file)")
        elif is_private and not has_lan:
            issues.append(f"{router} (private needs lan@file)")

    return issues


def find_config_issues(
    content: str,
    service_name: str,
    exclude_logging: set[str] | None = None,
    exclude_network: set[str] | None = None,
) -> list[str]:
    exclude_logging = exclude_logging or set()
    exclude_network = exclude_network or set()
    issues = []

    if service_name not in exclude_logging:
        if "logging:" not in content:
            issues.append("missing logging")
        elif "driver: local" not in content:
            issues.append("logging: use driver: local")

    if service_name not in exclude_network:
        if "reverse-proxy" not in content and "network_mode" not in content:
            issues.append("missing network: reverse-proxy")

    return issues


def lint_service(service_dir: Path, config: LintConfig) -> ServiceLint:
    result = ServiceLint(name=service_dir.name, path=service_dir)
    compose_file = service_dir / "compose.yml"

    if not compose_file.exists():
        return result

    content = compose_file.read_text()
    service_props = extract_compose_service_props(content)

    for container_name, props in service_props.items():
        order_issues = find_order_fixes(props)
        for issue in order_issues:
            issue.message = f"{container_name}{issue.message}"
            result.order_issues.append(issue)

    result.router_issues = find_router_issues(content, config.exclude_routers)
    result.middleware_issues = find_middleware_issues(content, config.exclude_middlewares)
    result.config_issues = find_config_issues(
        content,
        service_dir.name,
        config.exclude_logging,
        config.exclude_network,
    )
    return result


def cmd_lint(args) -> int:
    service_name = args.service
    config = load_config()

    if service_name:
        services = [NAS_DIR / service_name]
        if not services[0].exists():
            print(f"{Colors.RED}Error: Service not found: {service_name}{Colors.RESET}")
            return 1
    else:
        services = get_services()

    results: list[ServiceLint] = []
    for service_dir in services:
        if (service_dir / "compose.yml").exists():
            results.append(lint_service(service_dir, config))

    table = Table(["Service", "Order", "Routers", "Middlewares", "Config"])
    failed_services: list[ServiceLint] = []

    for r in results:
        order_str = f"{Colors.RED}{len(r.order_issues)}{Colors.RESET}" if r.order_issues else f"{Colors.GRAY}-{Colors.RESET}"
        router_str = f"{Colors.RED}{len(r.router_issues)}{Colors.RESET}" if r.router_issues else f"{Colors.GRAY}-{Colors.RESET}"
        middleware_str = f"{Colors.RED}{len(r.middleware_issues)}{Colors.RESET}" if r.middleware_issues else f"{Colors.GRAY}-{Colors.RESET}"
        config_str = f"{Colors.RED}{len(r.config_issues)}{Colors.RESET}" if r.config_issues else f"{Colors.GRAY}-{Colors.RESET}"

        if r.has_errors:
            table.add_row([f"{Colors.RED}{r.name}{Colors.RESET}", order_str, router_str, middleware_str, config_str])
            failed_services.append(r)
        else:
            table.add_row([f"{Colors.GREEN}{r.name}{Colors.RESET}", order_str, router_str, middleware_str, config_str])

    print()
    print(table.render())

    if failed_services:
        order_services = [s for s in failed_services if s.order_issues]
        if order_services:
            print(f"\n{Colors.BOLD}Property Order{Colors.RESET}")
            for svc in order_services:
                print(f"  {Colors.CYAN}{svc.name}/compose.yml{Colors.RESET}")
                for issue in svc.order_issues:
                    print(f"    {Colors.GRAY}{issue.message}{Colors.RESET}  {issue.fix}")

        router_services = [s for s in failed_services if s.router_issues]
        if router_services:
            print(f"\n{Colors.BOLD}Router Naming{Colors.RESET}")
            for svc in router_services:
                print(f"  {Colors.CYAN}{svc.name}{Colors.RESET}")
                for issue in svc.router_issues[:5]:
                    print(f"    {issue}")
                if len(svc.router_issues) > 5:
                    print(f"    {Colors.GRAY}+{len(svc.router_issues) - 5} more{Colors.RESET}")

        middleware_services = [s for s in failed_services if s.middleware_issues]
        if middleware_services:
            print(f"\n{Colors.BOLD}Middlewares{Colors.RESET}")
            for svc in middleware_services:
                print(f"  {Colors.CYAN}{svc.name}{Colors.RESET}")
                for issue in svc.middleware_issues[:5]:
                    print(f"    {issue}")
                if len(svc.middleware_issues) > 5:
                    print(f"    {Colors.GRAY}+{len(svc.middleware_issues) - 5} more{Colors.RESET}")

        config_services = [s for s in failed_services if s.config_issues]
        if config_services:
            print(f"\n{Colors.BOLD}Configuration{Colors.RESET}")
            for svc in config_services:
                issues = ", ".join(svc.config_issues)
                print(f"  {Colors.CYAN}{svc.name}{Colors.RESET}  {issues}")

    total_errors = sum(s.error_count for s in failed_services)
    print()
    if total_errors > 0:
        print(f"{Colors.RED}{total_errors} issue(s) in {len(failed_services)} service(s){Colors.RESET}")
        return 1
    else:
        print(f"{Colors.GREEN}All {len(results)} services passed{Colors.RESET}")
        return 0


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="homelab",
        description="Tooling for managing Docker services on the NAS",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  homelab lint              Lint all services
  homelab lint paperless    Lint specific service
  homelab env sync          Sync all .env files
  homelab env sync -f       Sync without confirmation
""",
    )
    parser.add_argument("-v", "--version", action="version", version=f"%(prog)s {__version__}")
    parser.add_argument("--no-color", action="store_true", help="Disable colored output")

    subparsers = parser.add_subparsers(dest="command", metavar="<command>")

    lint_parser = subparsers.add_parser("lint", aliases=["check"], help="Check compose.yml files")
    lint_parser.add_argument("service", nargs="?", metavar="<service>")
    lint_parser.set_defaults(func=cmd_lint)

    env_parser = subparsers.add_parser("env", help="Environment file operations")
    env_subparsers = env_parser.add_subparsers(dest="env_command", metavar="<subcommand>")

    sync_parser = env_subparsers.add_parser("sync", aliases=["s"], help="Sync .env with .env.example")
    sync_parser.add_argument("service", nargs="?", metavar="<service>")
    sync_parser.add_argument("-f", "--force", action="store_true", help="No confirmation")
    sync_parser.set_defaults(func=cmd_env_sync)

    args = parser.parse_args()

    if args.no_color or not sys.stdout.isatty():
        Colors.disable()

    if args.command is None:
        parser.print_help()
        return 0

    if args.command == "env" and getattr(args, "env_command", None) is None:
        env_parser.print_help()
        return 0

    if hasattr(args, "func"):
        return args.func(args)

    parser.print_help()
    return 0


if __name__ == "__main__":
    sys.exit(main())
